# CS-300-Analysis-and-Design

What was the problem you were solving in the projects for this course?

The projects focused on implementing and analyzing different data structures to  efficiently store, retrieve and manipulate course information. Project One       involved evaluating the runtime and memory usage of vectors, BTS and hash tables.  Project Two required building a system to load, store and display data in     alphanumeric order using a BST.

How did you approach the problem? Consider why data structures are important to understand.

The approach involved analyzing the efficiency of different data structures and selecting the best one for a given scenario. Understanding data structures is crucial because they directly impact the performance of operations such as searching, inserting and sorting. The BST was chosen for Project Two because it naturally maintains sorted order, making it efficient for retrieving course lists in alphanumeric order.

How did you overcome any roadblocks you encountered while going through the activities or project?

One challenge was ensuring that prerequisite courses existed before inserting them into the BST. Debugging involved adding print statements to verify data parsing and course insertion. Another challenge was sorting and displaying courses efficiently, which required refining the BST traversal logic.

How has your work on this project expanded your approach to designing software and developing programs?

This project reinforced the importance of selecting the right data structure for a given task. It also emphasized the need for clear, maintainable code and the role of debugging and testing in software development. The experience highlighted the trade-offs between runtime efficiency and ease of implementation.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

The project encouraged writing structured, well-documented code with meaningful function names and modular design. Using a BST helped maintain readability and efficiency, while the debuggingh process reinforced the importance of clear logging and structured data handling. The lessons learned will help in writing scalable and adaptable code in future projects.
